module sample uses std, file, image

#include "libutil"

struct File {
    handle: runtime_ptr
}

fn file_open(path: string, mode: string) -> File {
    return new File {
        handle: runtime::fopen(path, mode)
    }
}

fn File::dispose() {
    runtime::fclose(self.handle)
}

fn compare(a: Comparable, b: Comparable) -> int {
    return a.compare(b)
}

struct Color {
    r: float
    g: float
    b: float
    a: float
} is Equatable, Comparable

fn Color::luminosity() -> float {
    return self.r * 0.3 + self.g * 0.6 + self.b * 0.1
}

fn Color::r() -> self.r

fn Color::inverted() -> Color {
    return new self with {
        r: 255 - self.r
        g: 255 - self.g
        b: 255 - self.b
    }
}

interface Equatable {
    fn equals(obj: object) -> bool
}

struct Image {
    pixels: Color[]
    width: int
    height: int
}

fn Image::width() -> int {
    return self.width
}

fn Image::height() -> int {
    return self.height
}

fn Image::is_empty() -> bool {
    return true if self.width == 0 and self.height == 0 else false
}

let empty_image: Image = make_image(0, 0)

fn mutable Image::invert() {
    let px: mutable Color[] = self.pixels
    for y: int in 0 .. self.height {
        var index: int = y * self.width
        for x: int in 0 .. self.width {
            px[index] = px[index].inverted()
            index++
        }
    }
}

fn make_image(width: int, height: int) -> mutable Image {
    let size: int = width * height
    return new Image {
        pixels: new Color[size]
        width: width
        height: height
    }
}

union Number {
    f: float
    n: int
    b: byte
}

fn Number::f() -> self.f
fn mutable Number::f(v: float) {
    self.f = v
}

fn Number::to_int() -> int {
    return switch self {
        f: float -> round(f)
        n: int -> n
        b: byte -> (int) b
    }
}

fn Number::is_int() -> bool {
    return switch self {
        n: int -> true
        else -> false
    }
}
